═══════════════════════════════════════════════════════════════
네이버 전화번호 검색 프로그램 - 크롤링 참고 분석
═══════════════════════════════════════════════════════════════

📋 1. 프로젝트 개요
────────────────────────────────────────────────────────────────
• 목적: 구글 스프레드시트의 업소명으로 네이버 지도에서 전화번호 자동 검색
• 언어: Python 3.13+
• 배포: EXE 파일 (PyInstaller 사용)
• 크기: 약 45MB


🔧 2. 기술 스택
────────────────────────────────────────────────────────────────
[핵심 라이브러리]
├─ selenium==4.27.1                # 웹 자동화
├─ webdriver-manager==4.0.2        # ChromeDriver 자동 관리
├─ google-api-python-client==2.154.0  # Google Sheets API
├─ google-auth==2.36.0             # Google 인증
└─ python-dotenv==1.0.1            # 환경변수 관리

[GUI]
├─ tkinter (내장)                  # GUI 프레임워크
└─ threading (내장)                # 백그라운드 작업

[배포]
└─ pyinstaller==6.16.0             # EXE 빌드


🏗️ 3. 파일 구조
────────────────────────────────────────────────────────────────
NaverPhoneSearch_간편버전/
├─ NaverPhoneSearch.exe            # 실행 파일
├─ 사용방법.txt                    # 사용자 가이드
└─ 소스코드/
   ├─ phone_search_selenium_gui.py # GUI 메인 프로그램
   ├─ google_api_selenium.py       # 검색 로직
   ├─ requirements.txt             # 패키지 목록
   └─ 개발자가이드.txt             # 개발 문서


💡 4. 핵심 설계 원칙
────────────────────────────────────────────────────────────────
[사용자 편의성]
✓ Sheet ID만 입력하면 바로 사용 가능
✓ Python 설치 불필요 (EXE 단독 실행)
✓ 인증 정보를 코드에 내장 (별도 파일 불필요)
✓ ChromeDriver 자동 다운로드 (수동 설치 불필요)
✓ 브라우저 창 보이게 (검색 과정 확인 가능)

[안정성]
✓ 여러 CSS 셀렉터 시도 (네이버 UI 변경 대응)
✓ 충분한 대기 시간 (4~5초)
✓ 검색 딜레이 (차단 방지)
✓ 에러 핸들링 (각 단계별 try-except)

[효율성]
✓ 기존 전화번호 스킵
✓ 잘못된 업소명 스킵
✓ 진행률 실시간 표시
✓ 일시정지/재개/중지 기능


🔍 5. 크롤링 로직 상세 분석
────────────────────────────────────────────────────────────────

[5.1 전체 흐름]
1. Google Sheets에서 데이터 읽기
2. 각 행의 업소명으로 네이버 지도 검색
3. 주소 매칭으로 정확한 업체 찾기
4. 전화번호 추출 후 Sheets에 저장

[5.2 주소 매칭 로직]
def extract_si_gun_gu(address):
    """
    주소에서 시/군/구만 추출하여 매칭에 사용

    예시:
    입력: "전주시 완산구 12-1(중앙동)"
    출력: ["전주시", "완산구"]

    이유: 상세 주소는 다를 수 있지만 시/군/구는 동일해야 함
    """

핵심 포인트:
• 광역시/도는 제외 (서울특별시, 경기도 등)
• 시/군/구만 추출 (최대 2개)
• 괄호와 번지수 제거
• 모든 키워드가 포함되는지 확인

[5.3 검색 시나리오]

시나리오 A: 검색 결과 1개 (바로 상세 페이지)
┌────────────────────────────────────┐
│ 1. 검색 → entryIframe 즉시 열림    │
│ 2. 업소명 확인 (부분 일치)         │
│ 3. 주소 확인 (시/군/구 일치)       │
│ 4. 매칭 성공 → 전화번호 추출       │
└────────────────────────────────────┘

시나리오 B: 검색 결과 여러 개 (리스트)
┌────────────────────────────────────┐
│ 1. 검색 → searchIframe 열림        │
│ 2. 리스트에서 주소 비교            │
│ 3. 일치하는 항목 클릭              │
│ 4. entryIframe 전환                │
│ 5. 전화번호 추출                   │
└────────────────────────────────────┘

[5.4 CSS 셀렉터 전략]
# 네이버 지도 UI가 자주 변경되므로 여러 셀렉터 시도

업소명 셀렉터 (우선순위):
1. span.Fc1rA
2. h1.GHAhO
3. div.YouOG span

주소 셀렉터 (우선순위):
1. span.LDgIH
2. div.O8qbU span.LDgIH
3. div.place_section span.LDgIH

전화번호 셀렉터:
1. span.xlx7Q (entryIframe)
2. div.place_section_content span.xlx7Q (main page)

[5.5 대기 시간 전략]
초기 페이지 로딩: 4초
클릭 후 상세 로딩: 5초
검색 간 딜레이: 1.5초 (설정 가능)

→ 안정성을 위해 넉넉하게 설정


🎨 6. GUI 설계
────────────────────────────────────────────────────────────────
[구성 요소]
1. Sheet ID 입력 필드
2. 컨트롤 버튼 (시작/일시정지/중지)
3. 진행률 바 + 통계
4. 검색 설정 (딜레이, 행 범위)
5. 로그 출력 (색상 구분)

[로그 색상 체계]
• 초록: 성공 (전화번호 찾음)
• 빨강: 실패 (전화번호 없음)
• 주황: 건너뜀 (이미 있음, 잘못된 입력)
• 파랑: 정보 (진행 상태)

[멀티스레딩]
• 메인 스레드: GUI 업데이트
• 백그라운드 스레드: 검색 실행
→ GUI 응답성 유지


🔐 7. 인증 처리
────────────────────────────────────────────────────────────────
[방식]
Service Account 방식 (OAuth 없이 바로 접근)

[구현]
1. credentials.json을 코드에 내장 (EMBEDDED_CREDENTIALS)
2. 실행 시 임시 파일로 저장
3. API 연결 후 임시 파일 삭제

[장점]
✓ 사용자가 별도 인증 파일 관리 불필요
✓ EXE 단독 실행 가능

[단점]
⚠ Sheet를 "링크가 있는 모든 사용자 - 편집자"로 공유 필요
⚠ Sheet ID 노출 주의


📦 8. EXE 빌드 방법
────────────────────────────────────────────────────────────────
pyinstaller --onefile --windowed \
  --name=NaverPhoneSearch \
  --hidden-import=selenium \
  --hidden-import=webdriver_manager \
  --hidden-import=google \
  --collect-all=selenium \
  --collect-all=webdriver_manager \
  phone_search_selenium_gui.py

[빌드 옵션 설명]
--onefile         : 단일 EXE 파일 생성
--windowed        : 콘솔 창 숨기기
--hidden-import   : 숨겨진 모듈 포함
--collect-all     : 패키지 전체 포함

[주의사항]
• ChromeDriver는 EXE에 미포함 (첫 실행 시 자동 다운로드)
• credentials.json은 코드에 내장됨


🛡️ 9. 봇 감지 우회
────────────────────────────────────────────────────────────────
chrome_options.add_argument('--disable-blink-features=AutomationControlled')
chrome_options.add_experimental_option('useAutomationExtension', False)

→ Selenium 자동화 감지 우회


⚙️ 10. 환경 설정
────────────────────────────────────────────────────────────────
[환경변수 (.env 파일)]
GOOGLE_SHEET_ID=<Sheet ID>
GOOGLE_SERVICE_ACCOUNT_FILE=credentials.json
SEARCH_DELAY=1.5
HEADLESS_MODE=false

[GUI 설정]
• 시작 행: 3 (1~2행은 헤더)
• 종료 행: 0 (끝까지)
• 검색 딜레이: 1.5초 (0.5~5초 조절 가능)


📊 11. Google Sheets 구조
────────────────────────────────────────────────────────────────
┌──┬───┬───┬─────────┬───┬──────────┬───┬──────────────┐
│A │ B │ C │    D    │ E │    F     │ G │      H       │
├──┼───┼───┼─────────┼───┼──────────┼───┼──────────────┤
│번호│...│...│  업소명  │...│ 전화번호 │...│    주소      │
└──┴───┴───┴─────────┴───┴──────────┴───┴──────────────┘

[컬럼 역할]
D열(4번째): 검색할 업소명 (입력)
F열(6번째): 전화번호 (출력) ← 프로그램이 자동 저장
H열(8번째): 주소 (입력, 매칭용)

[데이터 처리]
• 1~2행: 헤더 (자동 건너뜀)
• 3행부터: 실제 데이터


🔄 12. 에러 핸들링 전략
────────────────────────────────────────────────────────────────
[레벨 1: 항목 스킵]
• 업소명이 비어있거나 "업소명"인 경우
• 이미 전화번호가 있는 경우
→ 다음 항목으로 이동

[레벨 2: 검색 실패]
• 네이버 지도에서 결과 없음
• 주소 불일치
• 전화번호 요소를 찾을 수 없음
→ 로그 기록 후 다음 항목

[레벨 3: 치명적 오류]
• Sheet 읽기 실패
• API 연결 실패
→ 프로그램 중지, 오류 메시지 표시


⚡ 13. 성능 최적화
────────────────────────────────────────────────────────────────
[Chrome 로그 억제]
chrome_options.add_argument('--log-level=3')
chrome_options.add_argument('--disable-logging')
chrome_options.add_experimental_option('excludeSwitches', ['enable-logging'])

[브라우저 재사용 전략]
• 각 검색마다 브라우저 새로 열기 (driver.quit())
• 메모리 누수 방지
• 안정성 향상

[대기 전략]
• 명시적 대기: WebDriverWait (최대 10초)
• 암묵적 대기: time.sleep (4~5초)
→ 네트워크 상황에 따라 조절


🎯 14. 핵심 코드 패턴
────────────────────────────────────────────────────────────────

[패턴 1: 여러 셀렉터 시도]
```python
name_selectors = ['span.Fc1rA', 'h1.GHAhO', 'div.YouOG span']
found_name = ""
for selector in name_selectors:
    name_elems = driver.find_elements(By.CSS_SELECTOR, selector)
    if name_elems and name_elems[0].text:
        found_name = name_elems[0].text
        break
```

[패턴 2: iframe 전환]
```python
driver.switch_to.default_content()  # 메인으로 돌아가기
wait.until(EC.frame_to_be_available_and_switch_to_it((By.ID, 'entryIframe')))
```

[패턴 3: 전화번호 포맷팅]
```python
def extract_phone_number(text):
    numbers = re.sub(r'[^\d]', '', text)  # 숫자만 추출

    if numbers.startswith('02'):
        return f"{numbers[:2]}-{numbers[2:6]}-{numbers[6:]}"
    elif len(numbers) == 10:
        return f"{numbers[:3]}-{numbers[3:6]}-{numbers[6:]}"
    elif len(numbers) == 11:
        return f"{numbers[:3]}-{numbers[3:7]}-{numbers[7:]}"
```

[패턴 4: 주소 매칭]
```python
# 시/군/구 추출
target_keywords = extract_si_gun_gu(address)

# 모든 키워드가 포함되는지 확인
addr_match = all(kw in found_addr for kw in target_keywords)
```


📝 15. 요기요 크롤링 적용 시 고려사항
────────────────────────────────────────────────────────────────

[재사용 가능한 패턴]
✓ Selenium + webdriver-manager 조합
✓ GUI (tkinter) 구조
✓ 진행률 표시 + 로그 시스템
✓ 일시정지/재개/중지 기능
✓ Google Sheets 연동
✓ 여러 셀렉터 시도 전략
✓ EXE 빌드 방법

[수정 필요한 부분]
✗ 검색 URL (네이버 지도 → 요기요)
✗ CSS 셀렉터 (요기요 사이트 구조 분석 필요)
✗ 데이터 구조 (전화번호 → 메뉴/가격 정보)
✗ 로그인 처리 (요기요는 로그인 필요할 수 있음)
✗ 페이지네이션 (여러 페이지 처리)
✗ 대기 시간 (사이트 속도에 따라)

[요기요 특화 고려사항]
• 요기요 사이트 구조 분석 (개발자 도구)
• 로그인 필요 여부 확인
• API 사용 가능 여부 확인 (더 안정적)
• 검색 vs 카테고리 탐색
• 지역별 필터링
• 메뉴 정보 추출 방법
• 이미지 다운로드 필요 여부


🚨 16. 주의사항
────────────────────────────────────────────────────────────────
[법적 고려사항]
⚠ robots.txt 확인 필수
⚠ 이용약관 위반 여부 확인
⚠ 개인정보 수집 주의
⚠ 상업적 이용 시 법적 검토

[기술적 제약]
⚠ 사이트 구조 변경 시 셀렉터 업데이트 필요
⚠ 차단 방지를 위한 딜레이 필수
⚠ IP 차단 가능성
⚠ CAPTCHA 처리 필요할 수 있음

[실행 환경]
⚠ Chrome 브라우저 설치 필요
⚠ 인터넷 연결 필수
⚠ Windows 10/11 권장


═══════════════════════════════════════════════════════════════
분석 완료
═══════════════════════════════════════════════════════════════
